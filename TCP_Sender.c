#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>  // POSIX operating system API access (e.g., close(), sleep())
#include <sys/socket.h>// Definitions of structures needed for sockets
#include <netinet/in.h> // Internet address family for stockade_in structure
#include <arpa/inet.h>// Functions for manipulating IP addresses
#include <netinet/tcp.h>// TCP-specific socket options and constants
#include <time.h> // Functions for manipulating time
#include <stddef.h>
#include "RUDP_API.h"


/**
 * Generates random data of the specified size.
 * 
 * @param size The size of the random data to generate.
 * @return A pointer to the buffer containing the generated random data.
 */
char *create_random_data(unsigned int size){
    char *buffer=NULL;// Pointer to the buffer for storing the random data
    if (size == 0){
        return NULL;
    }
    // Allocate memory for the buffer to store the random data
    buffer = (char *)calloc(size, sizeof(char));

     // Error checking: If memory allocation fails, return NULL
      if (buffer == NULL){
        return NULL;
    }    
    /*
    initializes the random number generator with a seed value based on the current time, 
    ensuring that the random numbers generated by rand() are different each time the program is executed.
    */
    srand(time(NULL));

     // Generate random data and store it in the buffer
     for (unsigned int i = 0; i < size; i++){
        *(buffer + i) = ((unsigned int)rand() % 256);  // Assign random values in the range [0, 255]
     }
     return buffer;   

}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <IP address> <port>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    char *ip_address = argv[1]; // Use argv[1] for IP address
    int port = atoi(argv[2]); // Use argv[2] for port

    int sockfd = -1;
    struct sockaddr_in server_addr;
    char message[] = "Hello, server!";

    while (1) {
        // Create RUDP socket if not already created
        if (sockfd < 0) {
            sockfd = rudp_socket(port); // Use port 0 for dynamic port assignment
            if (sockfd < 0) {
                fprintf(stderr, "Failed to create RUDP socket\n");
                exit(EXIT_FAILURE);
            }

            // Set up server address
            memset(&server_addr, 0, sizeof(server_addr));
            server_addr.sin_family = AF_INET;
            server_addr.sin_addr.s_addr = inet_addr(ip_address);
            server_addr.sin_port = htons(port);
        }

        // Send data to server using RUDP
        ssize_t bytes_sent = rudp_send(sockfd, server_addr, port, message, strlen(message));
        if (bytes_sent < 0) {
            fprintf(stderr, "Failed to send data using RUDP\n");
            close(sockfd);
            exit(EXIT_FAILURE);
        }

        printf("Message sent to server: %s\n", message);

        // Ask user if they want to send the message again
        char choice;
        printf("Do you want to send the message again? (y/n): ");
        scanf(" %c", &choice);

        if (choice != 'y' && choice != 'Y') {
            break; // Exit loop if user chooses not to send again
        }
    }

    // Close RUDP socket
    if (sockfd >= 0 && rudp_close(sockfd) < 0) {
        fprintf(stderr, "Failed to close RUDP socket\n");
        exit(EXIT_FAILURE);
    }

    return 0;
}
